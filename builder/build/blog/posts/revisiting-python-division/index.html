<!doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8">
    <title>
        blog | Revisiting Python Division
    </title>
    <meta name="description" content="Cameron Lane's homepage.">
    <meta name="viewport" content="width=device-width">
    <link rel="shortcut icon" href="/static/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/static/css/style.css?b8109c33">
    
    
</head>
<body class="blog">
    <div class="container">
        <header class="main-title">
            <h1><a href="/">Cameron <strong>Lane</strong></a></h1>
            <small>Erstwhile educator. Python programmer.</small>
        </header>
        <div class="contents">
            
    
     <h1>Exploring Python Division</h1>
<p><em>Note: This article refers to division as it exists in python 2.7.x. Subsequent releases of python do not behave the same way in all cases listed here</em></p>
<p>When learning a new programming language, one of the first things you encounter is how to do arithmetic on different types of numbers. It's such a common part of every language that we tend to take for granted that our arithmetical calculations will just work in all cases. It's important to realize that's not necessarily true. </p>
<p>I recently wrote a program that had a bug in it - a bug based on one of the edge cases involved in python's division operator. What follows is an overview of how python handles division and some of the ways it can lead to unexpected behavior for the unaware.</p>
<h2>Integer Division</h2>
<p>Most programming languages do integer division, meaning that when you divide two integers, the quotient will also be an integer. Any remainder of the division is simply discarded, even if the remainder is something other than 0. For example, consider these calculations: </p>
<pre><code class="python">&gt;&gt;&gt; 1 / 2
0
&gt;&gt;&gt; 3 / 2
1
</code></pre>

<p>The correct mathematical answer to the first computation is <code>0.5</code>. However, since both operands are integers, the answer (i.e., quotient) is also integer. Therefore, we get <code>0</code> as the solution to <code>1/2</code>, and <code>1</code> as the solution to <code>3/2</code>, even though the result has a remainder of <code>1</code> in both cases. While this can be confusing to the uninitiated, it is a familiar result for experienced programmers. </p>
<h2>Remainders</h2>
<p>Speaking of remainders, you cannot really talk about dividing two integers without also considering their remainder (we'll return to this soon). That is, if I divide an integer <code>a</code> by an integer <code>b</code>, what is left over? If <code>a</code> is evenly divisible by <code>b</code>, then the remainder will be <code>0</code>. Otherwise, the remainder will be an integer less than or equal to <code>b-1</code>. </p>
<p>In python, it's easy to get remainders using the modulus operator, <code>%</code>.</p>
<pre><code class="python">&gt;&gt;&gt; 1 % 2
1
&gt;&gt;&gt; 3 % 2
1
&gt;&gt;&gt; 4 % 2
0
&gt;&gt;&gt; 16 % 9 
7
</code></pre>

<p>Sometimes, it's helpful to get both the quotient and the remainder from an integer division at the same time. For this purpose, we have the builtin <code>divmod</code> function that returns a tuple <code>(q, r)</code>, where <code>q</code> is the quotient and <code>r</code> is the remainder of an integer division.</p>
<pre><code class="python">&gt;&gt;&gt; divmod(1, 2)
(0, 1)
&gt;&gt;&gt; divmod(3, 2)
(1, 1)
&gt;&gt;&gt; divmod(16, 9)
(1, 7)
&gt;&gt;&gt; divmod(16, 4)
(4, 0)
</code></pre>

<h2>Float Division</h2>
<p>So far, so good. But what if you want to force the answer to include the remainder (thus requiring a change to the type of the result) it is necessary to coerce the interpreter into using float division. One might think that something like <code>float(1/2)</code> would work, but that just gives a float version of the answer above. The easiest way to accomplish this is by explicitly forcing one of the operands to be a float.</p>
<pre><code class="python">&gt;&gt;&gt; 1.0 / 2
0.5
&gt;&gt;&gt; 1.0 * 3 / 2
1.5
&gt;&gt;&gt; float(3) / 2
1.5
&gt;&gt;&gt; 3. / 2
1.5
</code></pre>

<p>As expected, the first computation gives us the result <code>0.5</code>, and the second gives 1 with a remainder of 1 (<code>1+1/2 = 1.5</code>. Note that if <em>either</em> of the two operands is a <code>float</code>, the result will always be a <code>float</code>.</p>
<p>Again, this is familiar to most experienced programmers. However, it does introduce some unnecessary ambiguity into the behavior of the <code>/</code> division operator; namely, the <em>result of an expression involving the <code>/</code> cannot be determined without knowing the types of the arguments</em>. </p>
<p>At some point, Python's maintainers decided to resolve this ambiguity, because <a href="https://www.python.org/dev/peps/pep-0020/">explicit is always better than implicit</a></p>
<h2>Forcing Float Division</h2>
<p>There is a way to force python2 division to behave like python3 division, i.e., make it always do float division regardless of the types.  </p>
<pre><code class="python">&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; 1 / 2
0.5
</code></pre>

<p>As you can see, this import declaration overrides the default implementation of the <code>/</code> operator, coercing this example to produce the same output that <code>1.0 / 2</code> would normally produce in python 2. This can be useful if you know you're going to be dealing with integers and division and you want to avoid unexpected outcomes (for example, when calculating the mean of an integer valued data set). However, it is irreversible within a module or in an interactive session, so make sure that's what you want before you commit to it. </p>
<h2>Forcing Integer Division</h2>
<p>There is a also a way to force python into <em>always</em> discarding the remainder, regardless of the type of the operands. This is usually called <em>truncating division</em>, and is expressed using the <code>//</code> operator. It is available by default since python 2.2, so no need to import anything - you can just use it whenever you don't care about the remainder of a division operator.  </p>
<pre><code class="python">&gt;&gt;&gt; 1 // 2
0
&gt;&gt;&gt; 3 // 2
1
&gt;&gt;&gt; 1.0 // 2.0
0.0
&gt;&gt;&gt; 3.0 // 2
1.0
&gt;&gt;&gt; 3 // 2
1
</code></pre>

<p>Note that even though we discard any remainder of the division, the result still obeys the <code>match the type of our operand that requires the greatest precision (always float)</code> rule. Even when doing truncating integer division on floats, your answer will be a float.</p>
<h2>Dividing Negative Numbers</h2>
<p>So far, so good. However, we have only dealt with positive numbers. What happens when we allow our operands to be negative? Let's take a look at a few examples. </p>
<pre><code class="python">&gt;&gt;&gt; -1/2
-1
</code></pre>

<p>What!! How can <code>-1/2</code> give a result of <code>-1</code>? Mathematically, <code>-1/2</code> should give <code>-0.5</code> (2 goes into -1 zero times, and there is -1 as a remainder. Even if we use python's truncating integer division, we should expect to see <code>0</code> as the answer, not <code>-1</code>. Let's check some other examples to see if it we can make sense of it.</p>
<pre><code class="python">&gt;&gt;&gt; -1.0 / 2
-0.5
&gt;&gt;&gt; -1.0 // 2
-1.0
&gt;&gt;&gt; -3.0 // 2
-2.0
</code></pre>

<p>Okay, the first looks okay, but whenever integer division is required (the remainder discarded), it looks like dividing negative numbers makes they answer 1 whole integer less than the mathematically expected result.  What is going on?</p>
<h2>An Explanation</h2>
<p>Let's think back to the section on remainders. There, we noted that it's difficult to talk about integer division without also talking about <em>remainders</em> at the same time. As it turns out, the these two concepts are not only closely related mathemtical entities, they are also tightly coupled in python's implementation of integer division.</p>
<p>At some point in Python's development, Guido decided to preservethe formal, mathematical definitition of integer division and its remainder from number theory. Here it is:</p>
<ul>
<li><code>a / b = q</code> with remainder <code>r</code> such that <code>a = b*q + r</code> and <code>0 &lt;= r &lt; b</code></li>
</ul>
<p>This means that whenever dividing an integer <code>a</code> by a positive integer <code>b</code>, you can <em>always</em> expect <code>q &lt;= a</code> and <code>0 &lt;= r &lt; b</code>. No matter what. </p>
<p>For integer division problems where both dividend and divisor are positive numbers, this is fine. But what about our problem of a negative dividend? Well it can be shown that if you do the normal integer division thing and truncate in the direction of 0 (e.g., <code>-1//2 == 0</code>), then it forces the <em>remainder</em> of the division to be negative. This breaks the nice mathematical relationship between quotient and remainder mentioned above. </p>
<p>A second option is to round the quotient portion toward negative infinity, effectively doing <code>int(math.floor(1.0 * a/b))</code>, but at a much lower level. Now, when calculating the remainder, it satisfies the same constraint as above. </p>
<p>Python's designer chose this second option because it reinforces a certain mathematically consistent aesthetic on the division and remainder operators; it has the added benefit of making some calculations involving the remainder simpler. For example, if it were possible to obtain a negative remainder when using the <code>%</code> operator, it would needlessly complicate some easy calculations involving negative offsets from periodic patterns (i.e., What day of the week was it three days ago?). See the links at the end of this post for some concrete examples. </p>
<p>Many other language designers made different decisions. For example, most of the C style languages chose to keep a more intuitive (less surprising, at least) definition for division and remainder. </p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main(void) {
    int q = -1/2;
    printf(&quot;%s&quot;, q == 0 ? &quot;true&quot; : &quot;false&quot; ); // true
    return 0;
}
</code></pre>

<pre><code class="java">
import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be &quot;Main&quot; only if the class is public. */
class ExampleDivision
{
    public static void main (String[] args) throws java.lang.Exception
    {
        System.out.println(-1/2 == 0); // true
    }
}
</code></pre>

<p>Why did they make different decisions? I don't know, but in the case of C, Guido speculates that it may have been due to hardware limitations of the time, perhaps combined with the internal format used to represent signed ints (sign + magnitude, rather than two's complement). </p>
<h2>Conclusion</h2>
<p>Even though I have been doing python for quite a while now, it still has many dark secrets to yield.  In the course of writing a program, I hit a an unexpected behavior related to division that let me do the research featured in this post. It was nice to find that there is a rational (ha-ha!) explanation for the surprising behavior I encountered, but there are definitely some caveats that need to be attached to python division. So here are a few guidelines for dealing with python's division quirks:</p>
<ul>
<li>Use <code>from __future__ import division</code> to remove ambiguity about the <code>/</code> operator.</li>
<li>Be explicit about using <code>//</code> for integer division when it is necessary. </li>
<li>Be aware that dividing negative numbers using truncating integer division can yield surprising results!</li>
</ul>
<h2>Sources and Other References</h2>
<ul>
<li><a href="http://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html">Guido on Floored Division</a></li>
<li><a href="http://python-history.blogspot.com/2009/03/problem-with-integer-division.html">Guido on Integer Division</a></li>
<li><a href="http://en.wikipedia.org/wiki/Two%27s_complement">Two's Complement</a></li>
</ul>
     

    <div id="disqus_thread"></div>

        </div>
        <nav class="sidebar">
            <ul>
                <li class="home"><a href="/">home</a></li>
                <li class="blog"><a href="/blog/">blog</a></li>
                <li class="resume"><a href="/resume/">resume</a></li>
                <li class="contact"><a href="/contact/">contact</a></li>
            </ul>
        </nav>
        <footer class="site-footer">
            <p>
                &copy; 2012-2015 Cameron Lane
                - <a href="http://github.com/crlane">GitHub</a>
                - <a href="http://twitter.com/crlane">Twitter</a> 
            </p>
        </footer>
    </div>
    
        
    
    <script type="text/javascript" src="/static/js/app.js?d278a4a6"></script>
    
    
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'crlane'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
</body>
</html>